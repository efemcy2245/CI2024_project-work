# -*- coding: utf-8 -*-
"""symreg_user.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I_rvGrwI8Z3P6CMOg2UM3TKsY-s7bW4N
"""

import numpy as np
from icecream import ic
from numpy import *
import random
import copy
import tqdm.auto
from tqdm.auto import tqdm
import matplotlib.pyplot as plt
from collections import defaultdict

"""## Dataset and Validation"""

problem = np.load('problem_4.npz')
x = problem['x']
y = problem['y']
print(x.shape)
print(y.shape)

"""## Variable to extract operator

we can divide 2 array in:
- all function
- only mathematical
"""

all_attributes = dir(np)

# Filter for mathematical functions (callables that aren't classes or non-math utilities)
math_functions = {
    attr: getattr(np, attr)
    for attr in all_attributes
    if callable(getattr(np, attr)) and isinstance(getattr(np, attr), np.ufunc) }

#### ALL FUNCTIONS
print(math_functions)

desired_categories = ["add", "subtract", "multiply", "divide",  "power",
                        "sin", "cos","log"]

#- I will produce a tree only this subset of operation, is only to have toy examples
math_functions = { key: value for key, value in math_functions.items() if key in desired_categories}
print(math_functions)

dictionary_func_count = {'abs': 1, 'absolute': 1, 'acos': 1, 'acosh': 1, 'add': 2, 'arccos': 1, 'arccosh': 1, 'arcsin': 1, 'arcsinh': 1, 'arctan': 1, 'arctan2': 2, 'arctanh': 1, 'asin': 1, 'asinh': 1, 'atan': 1, 'atan2': 2, 'atanh': 1, 'bitwise_and': 2, 'bitwise_count': 1, 'bitwise_invert': 1, 'bitwise_left_shift': 2, 'bitwise_not': 1, 'bitwise_or': 2, 'bitwise_right_shift': 2, 'bitwise_xor': 2, 'cbrt': 1, 'ceil': 1, 'conj': 1, 'conjugate': 1, 'copysign': 2, 'cos': 1, 'cosh': 1, 'deg2rad': 1, 'degrees': 1, 'divide': 2, 'divmod': 2, 'equal': 2, 'exp': 1, 'exp2': 1, 'expm1': 1, 'fabs': 1, 'float_power': 2, 'floor': 1, 'floor_divide': 2, 'fmax': 2, 'fmin': 2, 'fmod': 2, 'frexp': 1, 'gcd': 2, 'greater': 2, 'greater_equal': 2, 'heaviside': 2, 'hypot': 2, 'invert': 1, 'isfinite': 1, 'isinf': 1, 'isnan': 1, 'isnat': 1, 'lcm': 2, 'ldexp': 2, 'left_shift': 2, 'less': 2, 'less_equal': 2, 'log': 1, 'log10': 1, 'log1p': 1, 'log2': 1, 'logaddexp': 2, 'logaddexp2': 2, 'logical_and': 2, 'logical_not': 1, 'logical_or': 2, 'logical_xor': 2, 'matmul': 2, 'maximum': 2, 'minimum': 2, 'mod': 2, 'modf': 1, 'multiply': 2, 'negative': 1, 'nextafter': 2, 'not_equal': 2, 'positive': 1, 'pow': 2, 'power': 2, 'rad2deg': 1, 'radians': 1, 'reciprocal': 1, 'remainder': 2, 'right_shift': 2, 'rint': 1, 'sign': 1, 'signbit': 1, 'sin': 1, 'sinh': 1, 'spacing': 1, 'sqrt': 1, 'square': 1, 'subtract': 2, 'tan': 1, 'tanh': 1, 'true_divide': 2, 'trunc': 1, 'vecdot': 2}
math_functions_count = { key:value for key , value in dictionary_func_count.items() if key in desired_categories}
print(math_functions_count)

inverted_dict = {}
for key, value in math_functions_count.items():
    inverted_dict.setdefault(value, []).append(key)

print(inverted_dict)

x_min = np.min(x)
x_max = np.max(x)
print("X_MIN ", x_min , "- X_MAX " ,x_max)

"""## Generation Node - Generation Tree - Full/Grow

Node Structure:
    
    -operator
    -left
    -right
    -value
    -MSE
"""

class Node:
    def __init__(self, operator=None, left=None, right=None, value=None  ):
        self.operator = operator  # Operator function (e.g., np.add)
        self.left = left          # Left child (Node)
        self.right = right        # Right child (Node)
        self.value = value        # Constant or variable (if leaf)


    def is_leaf(self):
        return self.operator is None

    def __str__(self):   #### __str__
        if self.is_leaf():
            return str(self.value)
        elif( self.left !=None and self.right!=None  ) :
            return f"({self.left} {self.operator.__name__} {self.right})"
        elif( self.left !=None and self.right==None ):
            return f"({self.operator.__name__} {self.left})"
        elif( self.left ==None and self.right!=None ):
            return f"({self.operator.__name__} {self.right})"

    def compute(self, variables_values):                ## variables_values is a dictionary
        if self.is_leaf():                              ## If it's a leaf, return the value (either constant or variable)
            if isinstance(self.value, str):  # Variable
                return variables_values[self.value]
            else:  # Constant
                return self.value

        if(self.left!=None and self.right!=None):
            left_value = self.left.compute(variables_values) #### here we are define the computation
            right_value = self.right.compute(variables_values)
            return self.operator(left_value, right_value)
        elif( self.left!=None and self.right==None):
            left_value = self.left.compute(variables_values) #### here we are define the computation
            return self.operator(left_value)
        elif( self.left==None and self.right!=None):              #### in theory this condition never happens
            right_value = self.right.compute(variables_values) #### in the above node, we go left or right and we recall again the function
            return self.operator(right_value)                  #### to have again this loop, the box in the box


    def print_attributes(self):
        print(f"Operator: {self.operator.__name__ if self.operator else 'None'}")
        print(f"Left: {self.left if self.left else 'None'}")
        print(f"Right: {self.right if self.right else 'None'}")
        print(f"Value: {self.value if self.value is not None else 'None'}")

def generate_full_tree(depth=4, variables={"x0":0, "x1":0}):
    global math_functions , math_functions_count , x_min , x_max
    if depth == 0:  # Create a leaf
        if random.random() < 0.5:
            return Node(value=random.uniform(x_min, x_max))  # Random constant
        else:
            return Node(value=random.choice(list(variables.keys())))  # Variable
    # Create an internal node (operator)
    keys = list(math_functions.keys())
    random_key = random.choice(keys)
    random_func = math_functions[random_key]
    random_count = math_functions_count[random_key]
    if(random_count==2 ):
        left = generate_full_tree(depth - 1, variables)
        right = generate_full_tree(depth - 1, variables)
    else:
        left  = generate_full_tree(depth - 1, variables)
        right = None               ##### we force the right node to have None attribute
    return Node(operator=random_func, left=left, right=right)

def generate_grow_tree(depth=3, variables={"x0":0, "x1":0}):
    global math_functions , math_functions_count, x_min , x_max

    if depth == 0 or (depth > 0 and random.random() < 0.2):  # Create a leaf
        if random.random() < 0.1:
            return Node(value=random.uniform(x_min, x_max))  # Random constant we have to decide what is the range of the random value
        else:
            return Node(value=random.choice(list(variables.keys())))  # Variable

    # Create an internal node (operator)  ######### HERE WE ADD THE MSE TO CONTINUE THE GROW
    keys = list(math_functions.keys())
    random_key = random.choice(keys)
    random_func = math_functions[random_key]
    random_count = math_functions_count[random_key]
    if(random_count==2 ):
        ###we cna use self on the
        left = generate_grow_tree(depth - 1, variables)
        right = generate_grow_tree(depth - 1, variables)
    else:
        left  = generate_grow_tree(depth - 1, variables)
        right = None               ##### we force the right node to have None attribute

    return Node(operator=random_func, left=left, right=right)

"""## MSE Function"""

def MSE_train(Node ):
    global x , y
    y_formula_generate =np.array([])
    for el in x.T:
        dictio = { f"x{e}": el[e].item() for e in range(len(el))     }
        out = Node.compute(dictio)
        y_formula_generate= np.append(y_formula_generate, out)

    scalar = 100*np.square(y-y_formula_generate).sum()/len(x)
    return (Node , str(Node) , scalar)

"""## Parent Selection"""

def tournament_selection(population, tournament_size=10):
    tournament_contestants = random.sample(population, tournament_size)
    tournament_contestants.sort(key=lambda x: x[2], reverse=False)
    return tournament_contestants[0]

### select mutation or recombination operator
def select_operation(mutation_prob=0.05, crossover_prob=0.95):
    global mutation_list, recombination_list

    rand = random.random()  # random number between 0 and 1
    if rand < mutation_prob:
        func= random.choices(mutation_list, weights=[0.4 ,0.2, 0.4], k=1)[0]
        return 1, func
    else:
        func= random.choices(recombination_list)
        return 2, func[0]

### method get a random sub node - return its sub-structure
def get_node(node):
    parent_node= None
    branch =None
    obj= node

    while True:
        value = random.random()
        if(value < 0.7): #### here we go deep in the node
            if( obj.right is not None and obj.left is not None   ):
                value = random.random()
                if(value < 0.5 ):
                    parent_node = obj
                    branch= "r"
                    obj=obj.right
                else:
                    parent_node = obj
                    branch= "l"
                    obj=obj.left
            elif( obj.right is None and obj.left is not None   ):
                parent_node = obj
                branch= "l"
                obj=obj.left

            elif(obj.right is not None and obj.left is None):
                parent_node = obj
                branch= "r"
                obj=obj.right

            elif(obj.operator is None):
                break                       ### the node is a leaf
        else:
            break
            #same the node

    return obj , parent_node ,branch

"""## Mutation Function"""

def hoist(obj_input):    ### hoist method: extract a sub-node and this will be the new generated node
    global math_functions , math_functions_count, inverted_dict
    obj= copy.deepcopy(obj_input)
    first_obj = copy.deepcopy(obj_input)
    i=0   ####check which level i'm modifying
    obj1_extracted , parent_node ,branch = get_node(obj)
    return obj1_extracted

def point_mutation(obj_input):    ### point mutation: modify the operator in a random part of the main node
    global math_functions , math_functions_count, inverted_dict
    obj= copy.deepcopy(obj_input)

    first_obj = copy.deepcopy(obj_input)
    i=0
    while True:
        if(i<=1000):
            value = random.random()
            if(value < 0.7): #### here we go deep in the node
                if( obj.right is not None and obj.left is not None   ):
                    value = random.random()
                    if(value < 0.5 ):
                        obj=obj.right
                    else:
                        obj=obj.left

                elif( obj.right is None and obj.left is not None   ):
                    obj=obj.left

                elif(obj.right is not None and obj.left is None):
                    obj=obj.right

                elif(obj.operator is None):
                    #break
                    obj = obj_input
            else:
                if(obj.operator is not None and (  obj.right is not None and obj.left is not None ) ):  ### binary ope
                    list_ope = inverted_dict[2]
                    random_key = random.choice(list_ope)
                    random_func = math_functions[random_key]
                    obj.operator= random_func
                    break

                elif(obj.operator is not None and ((  obj.right is not None and obj.left is None ) or ( obj.right is None and obj.left is not None   )  )  ):   ## unary operator
                    list_ope = inverted_dict[1]
                    random_key = random.choice(list_ope)
                    random_func = math_functions[random_key]
                    obj.operator= random_func
                    break
                else:
                    obj = obj_input
        else:
            obj=first_obj
            break
        i+=1

    return  obj

def permutation(obj_input):    ### permutation mutation: find a leaf level and invert its value or costant
    global math_functions , math_functions_count, inverted_dict
    obj= copy.deepcopy(obj_input)

    first_obj = copy.deepcopy(obj_input)
    i=0   ### check which level i'm modifying
    while True:
        if(i<1000):
            if( (obj.right is not None and obj.left is not None)   ):
                if( obj.right.value is not None and obj.left.value  is not None ):
                    l= obj.left.value
                    r= obj.right.value
                    obj.right.value = l
                    obj.left.value = r
                    break
                else:
                    value = random.random()
                    if(value < 0.5 ):
                        obj=obj.right
                    else:
                        obj=obj.left

            elif( obj.right is None and obj.left is not None   ):
                obj=obj.left

            elif(obj.right is not None and obj.left is None):
                obj=obj.right

            elif( obj.value is not None and ( obj.right is None and obj.left is None )):
                obj= first_obj
        else:
            obj=first_obj
            break
        i+=1
    return obj

"""## Recombination"""

def recombination(obj1 , obj2):
    global math_functions , math_functions_count, inverted_dict

    obj1_value= obj1
    obj2_value= obj2
    parent_node1 = None
    parent_node2 = None

    if(obj1_value.operator!= None ):
        while (parent_node1 is None and ( obj1_value.left is not None or  obj1_value.right is not None    )   ):
            obj1_extracted , parent_node1 ,branch1 = get_node(obj1_value)
    else:
        obj1_extracted = obj1_value
        parent_node1 = None
        branch1="root"

    extracted1 = copy.deepcopy(obj1_extracted)

    #print( "extracted to replace", id(obj1_extracted) , obj1_extracted)
    if(obj2_value.operator!= None ):
        while (parent_node2 is None and ( obj2_value.left is not None or  obj2_value.right is not None    ) ):
            obj2_extracted , parent_node2 ,branch2 = get_node(obj2_value)
    else:
        obj2_extracted = obj2_value
        parent_node2 = None
        branch2="root"
    #print("extracted to replace", id(obj2_extracted) , obj2_extracted)
    extracted2 = copy.deepcopy(obj2_extracted)

    if(branch1=="r"):
        parent_node1.right = extracted2
    elif(branch1=="l"):
        parent_node1.left = extracted2
    else:
        obj1_value = extracted2

    if(branch2=="r"):
        parent_node2.right = extracted1
    elif(branch2=="l"):
        parent_node2.left = extracted1
    else:
        obj2_value = extracted1
    return obj1_value, obj2_value

"""## List variable operator"""

mutation_list = [point_mutation , permutation, hoist ]
recombination_list = [recombination]

"""## Implementation of GP

### Generating pop
"""

def filtered_POP(POP):                             ### this method filter the population in 2 ways:
                                                   ### - POP variable can have at most 5 nodes with the same fitness
    float_value_counts = defaultdict(int)          ### - POP variable can have at most 5 nodes with the same string
    expression_counts = defaultdict(int)
    unique_strings = set()
    filtered_list = []

    for item in POP:
        node, expression, float_value = item

        # Check if the float value count is below the limit
        if float_value_counts[float_value] < 5 and expression_counts[expression] < 5:
            # Check if the string is unique
            if expression not in unique_strings:
                filtered_list.append(item)
                unique_strings.add(expression)
                float_value_counts[float_value] += 1
                expression_counts[expression] += 1
    return filtered_list

#### the variables_values is define by the number of row of x variable (matrix)
variables_values = { f"x{k}" : random.uniform(x_min, x_max) for k in range(len(x))}
variables_values

POP = []

def generate_POP(POP):                  ### generate_POP: uses 250 iteration to create both full and grow trees
    for i in range(500):                ###               with at least a solution measurable
        if(i<250):
            full_tree_standard = generate_full_tree(depth=3 , variables=variables_values )
            y_formula_generate_grow =np.array([])
            for el in x.T:
                dictio = { f"x{e}": el[e].item() for e in range(len(el))     }
                out = full_tree_standard.compute(dictio)
                y_formula_generate_grow= np.append(y_formula_generate_grow, out)

            fitness = 100*np.square(y-y_formula_generate_grow).sum()/len(x)
            #print(fitness)
            if( not (np.isnan(fitness))):
                POP.append( (full_tree_standard, str(full_tree_standard) ,fitness) )
            else:
                POP.append( (full_tree_standard,str(full_tree_standard) , np.float64(np.inf)) )
        else:
            grow_tree = generate_grow_tree(depth=3 , variables=variables_values )
            y_formula_generate_grow =np.array([])
            for el in x.T:
                dictio = { f"x{e}": el[e].item() for e in range(len(el))     }
                out = grow_tree.compute(dictio)
                #print("input ", dictio , " value output ", out)
                y_formula_generate_grow= np.append(y_formula_generate_grow, out)
            fitness = 100*np.square(y-y_formula_generate_grow).sum()/len(x)
            #print(fitness)
            if( not (np.isnan(fitness))):
                POP.append((grow_tree, str(grow_tree), fitness))
            else:
                POP.append( (grow_tree, str(grow_tree), np.float64(np.inf)) )
        i+=1

    POP = sorted(POP, key=lambda x: x[2])
    seen = set()
    POP = [(obj, value1, value2) for obj, value1, value2 in POP if value1 not in seen and not seen.add(value1)]
    POP = sorted(POP, key=lambda x: x[2])

generate_POP(POP)
POP= filtered_POP(POP)
POP = sorted(POP, key=lambda x: x[2])

while len(POP)<100:                    ### we generate the population with at least 100 samples
    generate_POP(POP)
    print(len(POP))
    POP= filtered_POP(POP)

POP = sorted(POP, key=lambda x: x[2])
for p in POP:
   print(p)

### OPEN STATE VARIABLE

"""
import pickle

# Load the variable
with open("population_variable_problem_8.pkl", "rb") as f:
    POP = pickle.load(f)
"""

"""## Simulation"""

MAX_STEPS=1_000
lenght_sample = int(len(POP)*0.20)       ### off_spring: 20% of the pop lenght

for steps in tqdm(range(MAX_STEPS)):
    off_spring = tournament_selection(POP,lenght_sample )
    off_spring_2 = tournament_selection(POP, lenght_sample)

    input_num, func = select_operation()                  ### if pick the recombination - we get infinite loop
    if( input_num==2 ):                                   ### recombination - 2
        result_1 , result_2 = recombination( off_spring[0] , off_spring_2[0]  )

        nd1, ns_string1, v1 = MSE_train(result_1)

        if( np.isnan(v1)):
            v1 = np.float64(np.inf)

        if(ns_string1!=off_spring[1] and ns_string1!=off_spring_2[2] ):

            POP.append( ( nd1, ns_string1, v1) )
            POP = sorted(POP, key=lambda x: x[2])

        nd2, ns_string2, v2 = MSE_train(result_2)
        if( np.isnan(v2)):
            v2 = np.float64(np.inf)

        if(ns_string2!=off_spring[1] and ns_string2!=off_spring_2[2] ):
            POP.append( ( nd2, ns_string2, v2) )
            POP = sorted(POP, key=lambda x: x[2])
    else:
        result_1 =func( off_spring[0] )
        if(result_1 is not None):
            nd1, ns_string1, v1 = MSE_train(result_1)
            if( np.isnan(v1)):
                v1 = np.float64(np.inf)
        if( str(off_spring[1])!=ns_string1 ):       #### avoid to add child with same fitness
            POP.append( ( nd1, ns_string1, v1)     )
            POP = sorted(POP, key=lambda x: x[2])

    POP = filtered_POP(POP)                         #### filter the POP HAVING A UNIQUE ELEMENT
    POP = POP[:500]

"""## Print Optimizee result"""

for p in POP:
    print(p)

"""
#### save state problem
import pickle
# Save to file
with open("population_variable_problem_4.pkl", "wb") as f:
    pickle.dump(POP, f)
"""